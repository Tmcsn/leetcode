## Unique Binary Search Trees

#### 一.题目理解

输入数字n，输出可以构成的不同二叉查找树的个数

#### 二。解题思路

很明显是一道动态规划问题，对于二叉查找树 可以分成三部分来看 根节点 左子树 和右子树  左子树所有节点都小于根节点 右子树所有节点都大于根节点 

因此可以建立dp数组  dp[n+1] 其中dp[0]==1 因为当左子树或右子树为空的时候也是一种情况  dp[i] 表示有i个节点的不同二叉查找树的个数

对于2个节点的情况 拿出一个节点作为根节点 例如以1作为根节点 则 其左子树为0个节点 右子树为1个节点  以2为根节点 则左子树为1个节点 右子树为0个节点

对于3给节点情况 以1为根节点 则左子树为0个节点 右子树为2个节点 （和2个节点的时候结果一致） 以2为根节点 左子树为1个节点 右子树为1个节点  以3为根节点 左子树为2个节点 右子树为0个节点

以此类推 

n个节点的时候  以1为根节点  左子树为0个节点 右子树为 n-1个节点 以2为根节点 左子树为1个节点  右子树为n-1-1 个节点  以i为根节点 左子树为i-1个节点 右子树为n-j-1个节点  以n为根节点  左子树为 n-1个节点 右子树为 0个节点

dp[n]=dp[0] * dp[n-1]+dp[1] * dp[n-1-1]+...dp[n-1]*dp[0]

`class Solution {
​    public int numTrees(int n) {
​        int [] result=new int[n+1];
​        result[0]=1;
​        result[1]=1;
​        for(int i=2;i<n+1;i++){
​            for(int j=0;j<=i-1;j++){
​                result[i]+=result[j]*result[i-j-1];
​            }
​        }
​        return result[n];
​    }
}`



